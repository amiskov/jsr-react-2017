# Занятие №3, 11 мая
Файл: `lesson3_react_ecosystem`, ветка [`3rd_lesson`](https://github.com/amiskov/js_ru_20_04_19_30/tree/3rd_lesson).

* API Реакта
* Экосистема
* Что делать можно, но не нужно

## Работа с реальным DOM
В основном мы работаем с Virtual DOM. Но иногда бывает нужно дернуть и браузерный. Например, если нужно узнать размеры/позиционирование отрендеренных компонентов. Виртуальный дом про физические характеристики (высота, ширина, позиционирование) компонентов не знает ничего. Так же при работе со сторонними библиотеками может пригодится.

`ref` – доступен только для компонентов на классах, не доступен в функциональных. Это атрибут компонента, в котором можно хранить ссылку на объект реального DOM (reference), который соответствует компоненту (должен быть уникальным):

```jsx harmony
// Задать руками
componentDidMount() {
    console.log(this.refs); // тут будет лежать
}
render() {
    return (<ul ref='ololoList'>
        {elements}
    </ul>)
}

// Динамический реф, старый подход
componentDidMount() {
    console.log(this.refs); // Объект, где ключ-значение — ref: element
}
render() {
    const {articles, isSectionOpen, toggleSection} = this.props;
    const elements = articles.map( article => <li key={article.id} ref={article.id}><Article /></li>);
}

// Динамический реф, современный подход — юзать функцию (не анонимную!)
render() {
    // ...
    return (
        <ul ref={this.getContainerRef}>
            {elements}
        </ul>
    )
}

// Будет вызвана, когда компонент буедт добавляться/убираться в DOM
getContainerRef = ref => {this.container = ref;}
```

Важно при формировании рефа через функцию не использовать анонимную функцию, иначе она будет каждый раз пересоздаваться при вызове `render()`. Передаем ссылку на существующую — все норм, ничего не пересоздается.

`key` и `ref` — зарезервированные Реактовские свойства компонентов.

`ref` — ссылки на созданные объекты (не только на DOM-ноды).

### `ref` на запись
`ref` используется в основном для чтения. На запись редко бывает действительно нужно. Реакт не уследит, если, например, удалить элемент. Просто перетрет. Но бывает нужно, например, при работе с внешними библиотеками (графики строить, например, или jQuery), которые работают с реальным DOM.

Если нам нужно встроить что-то из сторонней библиотеки, которая работает с обычным DOM, мы создаем компонент и в нем по `ref` отображаем, что нам надо. См. `Chart.js` и `App.js`. Т. к. мы в этом компоненте работаем с реальным DOM и изменения для нас Реакт не производит, то нам надо руками следить за изменениями. Например, с помощью `componentWillRecieveProps`.

`ref` можно давать и Реактовским компонентам. Это будут уже отрендеренные, имеющие пропсы и пр. атрибуты компоненты. Удобно, когда нужно узнать характеристики отрендеренных компонентов. В этом поможет `React.DOM.findDOMNode`, который вернет DOM-ноду, в которую отрендерен компонент.

Получив `ref` на компонент, можно с ним что-то делать: считывать пропсы, делать `ref.setState({})`. Но это нехорошо. Лучше не надо, только в экзотических случаях. Можно обойтись без императивных манипуляций — надо обходится.

## Использование `key`
`key` — это внутренний ключ, помощь Реактовскому алгоритму при реконсиляции (сравнивание отрендеренного DOM с виртуальным перед обновлением).

Если изменить `key`, то для реакта это будет сигнал, что элемент со старым `key` удалился, а с новым он не может найти и поэтому отрендерит.

См. `Chart.js` и `App.js`. Там `key` чарта завязан на переменную в стейте.

## Работа с инпутами и формами
В Реакте считается плохой практикой отдавать что-то на откуп самому дому. Например, просто рендерить текстовый инпут, не обрабатывая его поведение, оставляя без контроля.

Работа с реальным DOM в Реакте — это крайний случай! Нужен контроль, нужна декларативность. Нужню юзать обратный дата-флоу.

## Экосистема Реакта
На https://react.rocks/ есть разные компоненты.

[react-select](https://github.com/JedWatson/react-select) — популярный комбо-бокс (селект).

Запись, где сразу из анонимной функции возвращается объект (обернуто в скобки, чтоб интерпретатор сразу вычислял и не пытался искать тело функции):

```js
const options = this.props.articles.map(article => ({
    label: article.title,
    value: article.id
}))
```

Не стоит спешить обновлять Реакт до самой новой версии. Нужно подождать, чтоб компоненты подоспели.

Нормальная практика, организовывать компонент в папке:

```
Article/
    index.js
    styles.less 
```

В ReactNative стилей нету, поэтмоу там уже CSS в JS.

## Анимация в Реакте
Есть разные модули, мы рассмотрим то, что есть в Реакте: `CSSTransitionGroup`.

[`CSSTransitionGroup`](https://www.npmjs.com/package/react-addons-css-transition-group) — более высокоуровневый API над `react-transition-group`.

```jsx harmony
<CSSTransitionGroup
    transitionName="article"
    transitionEnterTimeout={500}
    transitionLeaveTimeout={300}>
    {getBody()}
</CSSTransitionGroup>
```

Таймауты надо обязательно передавать, чтобы в случае глюка анимации Реакт ее прекращал и занимался своими делами дальше, не ожидая окончания анимации.

Свои классы вешать на появление еще можно, а вот на исчезновение — сложно. Реакт работает и если что-то убирается из стейта, нам надо его как-то затормозить, чтоб он не сразу это убрал, а после анимации. Поэтому проще юзать `CSSTransitionGroup`.

## `shouldComponentUpdate` и удаление
`shouldComponentUpdate` удобнее использовать с иммутабельными структурами данных. При использовании обычных, мутабельных объектов и массивов мы можем сравнивать ссылки, а они будут одинаковыми, не смотря на то, что структуры данных могут измениться.
